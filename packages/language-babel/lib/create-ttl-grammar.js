'use strict';

/*global atom*/
let crypto = require('crypto');
let fs = require('fs-plus');
let path = require('path');
let CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports = class CreateTtlGrammar {

  constructor() {
    let observeConfig = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
    this.disposable = new CompositeDisposable();
    this.configChangedTimer = null;
    this.TTLSCOPENAME = `languagebabel.ttlextension`;

    if (observeConfig) {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, err => {
        if (err) reject({ err: err, member: 'addGrammars' });else resolve();
      });
    });
  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a filename
  // if a new grammar was created or rejects if a problem.
  createGrammar(_ref) {
    let ttlFilename = _ref.ttlFilename;
    let ttlFilenameAbsolute = _ref.ttlFilenameAbsolute;
    let grammarText = _ref.grammarText;

    return new Promise((resolve, reject) => {

      this.noGrammarFileExists(ttlFilename).then(() => this.removeGrammars()).then(() => {
        this.removeTtlLanguageFiles();
      }).then(() => this.createGrammarFile(ttlFilenameAbsolute, grammarText)).then(() => this.addGrammars(ttlFilenameAbsolute)).then(() => resolve(ttlFilename)).catch(err => {
        reject(err);
      });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename, text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, err => {
        if (err) reject({ err: err, member: 'createGrammarFile' });else resolve('New Grammar Created');
      });
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${ this.TTLSCOPENAME }",
  "fileTypes": [],
  "patterns": [
    ${ this.getTtlConfig().map(ttlString => this.createGrammarPatterns(ttlString)) }
  ]
}`;
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex + 1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/;

    if (matchString.length < 1 || !isValidIncludeScope.test(includeScope)) {
      throw { err: `Error in the Tagged Template Grammar String ${ ttlString }`, member: 'createGrammarPatterns' };
    }

    const escapeStringRegExp = /[|\\{}()[\]^$+*?.]/g;
    // Get a valid regexp escaped string. e.g. '/** @html */' -> '\/\*\* @html \*\/'
    matchString = matchString.replace(escapeStringRegExp, '\\\\$&');

    return `{
      "begin": "\\\\s*+(${ matchString })\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.grapahql.js" },
        "4": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<!\\\\\\\\)(\`)",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "${ includeScope }" }
      ]
    }`;
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars'));
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve, reject) => {
      fs.readdir(this.getGrammarPath(), (err, data) => {
        if (err) reject({ err: err, member: 'getGrammarFiles' });else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    var regex = /ttl-/;
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function (filename) {
      return regex.test(filename);
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    var hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${ hashString }.json`;
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // checks a ttl grammar filename exist and is writable
  // returns a Promise that rejects if file exists
  noGrammarFileExists(ttlFilename) {
    return new Promise((resolve, reject) => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), fs.F_OK, err => {
        err ? resolve(!!err) : reject({ err: false, member: 'noGrammarFileExists' });
      });
    });
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig() {
    if (this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout(() => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        this.createGrammar({ ttlFilename, ttlFilenameAbsolute, grammarText }).then(() => atom.notifications.addInfo('language-babel', { description: `Grammar created at \n${ ttlFilenameAbsolute }`, dismissable: true })).catch(err => {
          if (err.err) {
            atom.notifications.addWarning('language-babel', { description: `member: ${ err.member } got an Error:${ err.err }`, dismissable: true });
          }
        });
      } catch (err) {
        atom.notifications.addWarning('language-babel', { description: `Error:${ err.err }`, dismissable: true });
        return;
      }
    }, 10000);
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTLSCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then(ttlGrammarFiles => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,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SSxrQkFBVCxJQUErQixlQUEvQixFQUFnRDtBQUM5QyxZQUFJLHlCQUF5QixLQUFLLCtCQUFMLENBQXFDLGtCQUFyQyxDQUE3QjtBQUNBLFdBQUcsTUFBSCxDQUFVLHNCQUFWO0FBQ0Q7QUFDRixLQUxNLENBQVA7QUFPRDtBQTNNb0IsQ0FEdkIiLCJmaWxlIjoiY3JlYXRlLXR0bC1ncmFtbWFyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypnbG9iYWwgYXRvbSovXHJcbmxldCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxubGV0IGZzID0gcmVxdWlyZSgnZnMtcGx1cycpO1xyXG5sZXQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxubGV0IENvbXBvc2l0ZURpc3Bvc2FibGUgPSByZXF1aXJlKCdhdG9tJykuQ29tcG9zaXRlRGlzcG9zYWJsZTtcclxuXHJcbi8vIFRoaXMgQ2xhc3MgaXMgcmVwc29uc2libGUgZm9yIGNyZWF0aW5nIGEgbmV3IFRhZ2dlZCBUZW1wbGF0ZSBncmFtbWFyXHJcbi8vIG9uIGRldGVjdGlvbiBvZiBhIGNoYW5nZWQgVGFnZ2VkIFRlbXBsYXRlIENvbmZpZ3VyYXRpb24gaW4gdGhlIHBhY2thZ2Ugc2V0dGluZ3NcclxubW9kdWxlLmV4cG9ydHMgPVxyXG5jbGFzcyBDcmVhdGVUdGxHcmFtbWFyIHtcclxuXHJcbiAgZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgY29uZmlnQ2hhbmdlZFRpbWVyPSBudWxsO1xyXG4gIFRUTFNDT1BFTkFNRSA9IGBsYW5ndWFnZWJhYmVsLnR0bGV4dGVuc2lvbmBcclxuXHJcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZUNvbmZpZyA9IGZhbHNlKSB7XHJcbiAgICBpZiAob2JzZXJ2ZUNvbmZpZykgICB7XHJcbiAgICAgIC8vIGxvb2sgZm9yIGNoYW5nZXMgaW4gdGFnZ2VkIHRlbXBsYXRlIGhhbmRsZXJzXHJcbiAgICAgIHRoaXMuZGlzcG9zYWJsZS5hZGQoYXRvbS5jb25maWcub2JzZXJ2ZSgnbGFuZ3VhZ2UtYmFiZWwudGFnZ2VkVGVtcGxhdGVHcmFtbWFyJywgdGhpcy5vYnNlcnZlVHRsQ29uZmlnLmJpbmQodGhpcykpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gYWRkIG5ldyBncmFtbWFycyB0byByZWdpc3RyeVxyXG4gIGFkZEdyYW1tYXJzKGZpbGVuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBhdG9tLmdyYW1tYXJzLmxvYWRHcmFtbWFyKGZpbGVuYW1lLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgaWYgKCBlcnIpIHJlamVjdCh7ZXJyOiBlcnIsIG1lbWJlcjogJ2FkZEdyYW1tYXJzJyB9KTtcclxuICAgICAgICBlbHNlIHJlc29sdmUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiB0aGUgZ3JhbW1hciBleGlzdHMgdW5kZXIgdGhpcyBTSEEyNTYgZmlsZSBuYW1lXHJcbiAgLy8gSWYgbm90IHRoZW4gcmVtb3ZlIGFsbCB0dGwgZ3JhbW1hcnMgYW5kIGNyZWF0ZSBhIG5ldyBvbmVcclxuICAvLyBUaGlzIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgIHdpdGggYSBmaWxlbmFtZVxyXG4gIC8vIGlmIGEgbmV3IGdyYW1tYXIgd2FzIGNyZWF0ZWQgb3IgcmVqZWN0cyBpZiBhIHByb2JsZW0uXHJcbiAgY3JlYXRlR3JhbW1hcih7dHRsRmlsZW5hbWUsIHR0bEZpbGVuYW1lQWJzb2x1dGUsIGdyYW1tYXJUZXh0fSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG4gICAgICB0aGlzLm5vR3JhbW1hckZpbGVFeGlzdHModHRsRmlsZW5hbWUpXHJcbiAgICAgICAgLnRoZW4oICgpID0+IHRoaXMucmVtb3ZlR3JhbW1hcnMoKSApXHJcbiAgICAgICAgLnRoZW4oICgpID0+IHsgdGhpcy5yZW1vdmVUdGxMYW5ndWFnZUZpbGVzKCk7IH0gKVxyXG4gICAgICAgIC50aGVuKCAoKSA9PiB0aGlzLmNyZWF0ZUdyYW1tYXJGaWxlKHR0bEZpbGVuYW1lQWJzb2x1dGUsIGdyYW1tYXJUZXh0KSApXHJcbiAgICAgICAgLnRoZW4oICgpID0+IHRoaXMuYWRkR3JhbW1hcnModHRsRmlsZW5hbWVBYnNvbHV0ZSkgKVxyXG4gICAgICAgIC50aGVuKCAoKSA9PiByZXNvbHZlKHR0bEZpbGVuYW1lKSApXHJcbiAgICAgICAgLmNhdGNoKCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgdGhlIHR0bCBncmFtbWFyIGZpbGUgZm9yIHRoaXMgY29uZmlnXHJcbiAgY3JlYXRlR3JhbW1hckZpbGUoZmlsZW5hbWUsdGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZnMud3JpdGVGaWxlKGZpbGVuYW1lLCB0ZXh0LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KHtlcnI6IGVyciwgbWVtYmVyOiAnY3JlYXRlR3JhbW1hckZpbGUnIH0pO1xyXG4gICAgICAgIGVsc2UgcmVzb2x2ZSgnTmV3IEdyYW1tYXIgQ3JlYXRlZCcpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gY3JlYXRlIGEgR3JhbW1hciBmaWxlJ3MgSlNPTiB0ZXh0XHJcbiAgY3JlYXRlR3JhbW1hclRleHQoKSB7XHJcbiAgICByZXR1cm4gYHtcclxuICBcImNvbW1lbnRcIjogXCJBdXRvIGdlbmVyYXRlZCBUYWcgRXh0ZW5zaW9ucyBmb3IgbGFuZ3VhZ2UtYmFiZWxcIixcclxuICBcImNvbW1lbnRcIjogXCJQbGVhc2UgZG8gbm90IGVkaXQgdGhpcyBmaWxlIGRpcmVjdGx5XCIsXHJcbiAgXCJzY29wZU5hbWVcIjogXCIke3RoaXMuVFRMU0NPUEVOQU1FfVwiLFxyXG4gIFwiZmlsZVR5cGVzXCI6IFtdLFxyXG4gIFwicGF0dGVybnNcIjogW1xyXG4gICAgJHt0aGlzLmdldFR0bENvbmZpZygpLm1hcCggKHR0bFN0cmluZykgPT4gKHRoaXMuY3JlYXRlR3JhbW1hclBhdHRlcm5zKHR0bFN0cmluZykpICApIH1cclxuICBdXHJcbn1gO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGEgZ3JhbW1hcidzIHBhdHRlcm4gZGVyaXZlZCBmcm9tIGEgdGhlIHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmdcclxuICAvLyBpbiB0aGUgZm9ybSBtYXRjaFN0cmluZzppbmNsdWRlU2NvcGVcclxuICBjcmVhdGVHcmFtbWFyUGF0dGVybnModHRsU3RyaW5nKSB7XHJcbiAgICBsZXQgbGFzdENvbG9uSW5kZXggPSB0dGxTdHJpbmcubGFzdEluZGV4T2YoJzonKTtcclxuICAgIGxldCBtYXRjaFN0cmluZyA9IHR0bFN0cmluZy5zdWJzdHJpbmcoMCwgbGFzdENvbG9uSW5kZXgpO1xyXG4gICAgbGV0IGluY2x1ZGVTY29wZSA9IHR0bFN0cmluZy5zdWJzdHJpbmcobGFzdENvbG9uSW5kZXgrMSk7XHJcbiAgICBjb25zdCBpc1ZhbGlkSW5jbHVkZVNjb3BlID0gL14oW2EtekEtWl1cXHcqXFwuPykqKFxcdyMoW2EtekEtWl1cXHcqXFwuPykqKT9cXHckLztcclxuXHJcbiAgICBpZiAoIG1hdGNoU3RyaW5nLmxlbmd0aCA8IDEgfHwgIWlzVmFsaWRJbmNsdWRlU2NvcGUudGVzdChpbmNsdWRlU2NvcGUpKSB7XHJcbiAgICAgIHRocm93KHtlcnI6IGBFcnJvciBpbiB0aGUgVGFnZ2VkIFRlbXBsYXRlIEdyYW1tYXIgU3RyaW5nICR7dHRsU3RyaW5nfWAsIG1lbWJlcjogJ2NyZWF0ZUdyYW1tYXJQYXR0ZXJucyd9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlc2NhcGVTdHJpbmdSZWdFeHAgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XHJcbiAgICAvLyBHZXQgYSB2YWxpZCByZWdleHAgZXNjYXBlZCBzdHJpbmcuIGUuZy4gJy8qKiBAaHRtbCAqLycgLT4gJ1xcL1xcKlxcKiBAaHRtbCBcXCpcXC8nXHJcbiAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UoZXNjYXBlU3RyaW5nUmVnRXhwLCAnXFxcXFxcXFwkJicpO1xyXG5cclxuICAgIHJldHVybiBge1xyXG4gICAgICBcImJlZ2luXCI6IFwiXFxcXFxcXFxzKisoJHttYXRjaFN0cmluZ30pXFxcXFxcXFxzKihcXGApXCIsXHJcbiAgICAgIFwiYmVnaW5DYXB0dXJlc1wiOiB7XHJcbiAgICAgICAgXCIxXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUudGFnLmdyYXBhaHFsLmpzXCIgfSxcclxuICAgICAgICBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmJlZ2luLmpzXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcImVuZFwiOiBcIlxcXFxcXFxccyooPzwhXFxcXFxcXFxcXFxcXFxcXCkoXFxgKVwiLFxyXG4gICAgICBcImVuZENhcHR1cmVzXCI6IHtcclxuICAgICAgICBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmVuZC5qc1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJwYXR0ZXJuc1wiOiBbXHJcbiAgICAgICAgeyBcImluY2x1ZGVcIjogXCIke2luY2x1ZGVTY29wZX1cIiB9XHJcbiAgICAgIF1cclxuICAgIH1gO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGZ1bGwgcGF0aCB0byB0aGUgbGFuZ3VhZ2UtYmFiZWwgZ3JhbW1hciBmaWxlIGRpclxyXG4gIGdldEdyYW1tYXJQYXRoKCkge1xyXG4gICAgcmV0dXJuIHBhdGgubm9ybWFsaXplKFxyXG4gICAgICBwYXRoLnJlc29sdmUoYXRvbS5wYWNrYWdlcy5sb2FkZWRQYWNrYWdlc1snbGFuZ3VhZ2UtYmFiZWwnXS5wYXRoLCAnLi9ncmFtbWFycycpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGFuIGFycmF5IG9mIGFsbCBsYW5ndWFnZS1iYWJlbCBncmFtbWFyIGZpbGVzXHJcbiAgZ2V0R3JhbW1hckZpbGVzKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCkgPT4ge1xyXG4gICAgICBmcy5yZWFkZGlyKHRoaXMuZ2V0R3JhbW1hclBhdGgoKSwoZXJyLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KHtlcnI6IGVyciwgbWVtYmVyOiAnZ2V0R3JhbW1hckZpbGVzJyB9KTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVhZCBjb25maWd1cmF0aW9ucyBmb3IgdGFnZ2VkIHRlbXBsYXRlc1xyXG4gIGdldFR0bENvbmZpZygpIHtcclxuICAgIHJldHVybiBhdG9tLmNvbmZpZy5nZXQoJ2xhbmd1YWdlLWJhYmVsJykudGFnZ2VkVGVtcGxhdGVHcmFtbWFyO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGFuIGFycmF5IG9mIGdyYW1tYXIgdGFnZ2VkIHRlbXBsYXRlIGV4dGVuc2lvbiBmaWxlbmFtZXNcclxuICBnZXRUdGxHcmFtbWFyRmlsZXMoKSB7XHJcbiAgICB2YXIgcmVnZXggPSAvdHRsLS87XHJcbiAgICByZXR1cm4gdGhpcy5nZXRHcmFtbWFyRmlsZXMoKS50aGVuKGRpckZpbGVzID0+IGRpckZpbGVzLmZpbHRlcihmdW5jdGlvbihmaWxlbmFtZSkge1xyXG4gICAgICByZXR1cm4gcmVnZXgudGVzdChmaWxlbmFtZSk7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICAvLyBnZW5lcmF0ZSBhIFNIQTI1NiBmb3Igc29tZSB0ZXh0XHJcbiAgZ2VuZXJhdGVUdGxTSEEyNTYoc3RyaW5nVG9IYXNoKSB7XHJcbiAgICB2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcclxuICAgIGhhc2gudXBkYXRlKHN0cmluZ1RvSGFzaCk7XHJcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gdGFnZ2VkIHRlbXBsYXRlIGZpbGVuYW1lXHJcbiAgbWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYHR0bC0ke2hhc2hTdHJpbmd9Lmpzb25gO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGEgZnVsbHkgcXVhbGlmaWVkIGZpbGVuYW1lXHJcbiAgbWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSkge1xyXG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLmdldEdyYW1tYXJQYXRoKCksIHR0bEZpbGVuYW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrcyBhIHR0bCBncmFtbWFyIGZpbGVuYW1lIGV4aXN0IGFuZCBpcyB3cml0YWJsZVxyXG4gIC8vIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVqZWN0cyBpZiBmaWxlIGV4aXN0c1xyXG4gIG5vR3JhbW1hckZpbGVFeGlzdHModHRsRmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZzLmFjY2Vzcyh0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsRmlsZW5hbWUpLCBmcy5GX09LLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgZXJyID8gcmVzb2x2ZSghIWVycik6IHJlamVjdCh7ZXJyOiBmYWxzZSwgbWVtYmVyOiAnbm9HcmFtbWFyRmlsZUV4aXN0cycgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBvYnNlcnZlIGNoYW5nZXMgaW4gdGhlIHRhZ2dlZFRlbXBsYXRlR3JhbW1hciBjb25maWcgd2hpY2ggdGFrZSBwbGFjZVxyXG4gIC8vIGJlY2F1c2Ugb2JzZXJ2ZWQgY29uZmlnIGNoYW5nZXMgYXJlIGZpcmVkIGFzIGEgdXNlciB0eXBlcyB0aGVtIGluc2lkZVxyXG4gIC8vIHNldHRpbmdzIHdlIG5lZWQgdG8gZGVsYXkgcHJvY2Vzc2luZyB0aGUgYXJyYXkgc3RyaW5ncywgdW50aWwgbGFzdCBjaGFyXHJcbiAgLy8gZW50ZXJlZCB3YXMgc2V0VGltZW91dCBzZWNvbmRzIGFnby4gcGFyc2UgdGFnZ2VkIHRlbXBsYXRlIGNvbmZpZ3VyYXRpb25cclxuICAvLyBhbmQgdGhlbiBjcmVhdGUgZ3JhbW1hciBhbmQgZ2VuZXJhdGUgYSBTSEEyNTYgaGFzaCBmcm9tIHRoZSBncmFtbWFyXHJcbiAgb2JzZXJ2ZVR0bENvbmZpZygpIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZ0NoYW5nZWRUaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuY29uZmlnQ2hhbmdlZFRpbWVyKTtcclxuICAgIHRoaXMuY29uZmlnQ2hhbmdlZFRpbWVyID0gc2V0VGltZW91dCggKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGdyYW1tYXJUZXh0ID0gdGhpcy5jcmVhdGVHcmFtbWFyVGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmdlbmVyYXRlVHRsU0hBMjU2KGdyYW1tYXJUZXh0KTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoKTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZUFic29sdXRlID0gdGhpcy5tYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlKHR0bEZpbGVuYW1lKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUdyYW1tYXIoe3R0bEZpbGVuYW1lLCB0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dCB9KVxyXG4gICAgICAgICAgLnRoZW4oICgpID0+IGF0b20ubm90aWZpY2F0aW9ucy5hZGRJbmZvKCdsYW5ndWFnZS1iYWJlbCcsIHtkZXNjcmlwdGlvbjogYEdyYW1tYXIgY3JlYXRlZCBhdCBcXG4ke3R0bEZpbGVuYW1lQWJzb2x1dGV9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pKVxyXG4gICAgICAgICAgLmNhdGNoKCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKGVyci5lcnIpIHtcclxuICAgICAgICAgICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRXYXJuaW5nKCdsYW5ndWFnZS1iYWJlbCcsIHtkZXNjcmlwdGlvbjogYG1lbWJlcjogJHtlcnIubWVtYmVyfSBnb3QgYW4gRXJyb3I6JHtlcnIuZXJyfWAsZGlzbWlzc2FibGU6IHRydWV9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaChlcnIpIHtcclxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkV2FybmluZygnbGFuZ3VhZ2UtYmFiZWwnLCB7ZGVzY3JpcHRpb246IGBFcnJvcjoke2Vyci5lcnJ9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwMDApO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGdyYW1tYXJzIGJlZm9yZSB1cG9kYXRpbmdcclxuICByZW1vdmVHcmFtbWFycygpIHtcclxuICAgIGF0b20uZ3JhbW1hcnMucmVtb3ZlR3JhbW1hckZvclNjb3BlTmFtZSh0aGlzLlRUTFNDT1BFTkFNRSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYWxsIGxhbmd1YWdlIGZpbGVzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBHcmFtbWFyRmlsZXMgYXJyYXlcclxuICByZW1vdmVUdGxMYW5ndWFnZUZpbGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHRsR3JhbW1hckZpbGVzKCkudGhlbiggKHR0bEdyYW1tYXJGaWxlcykgPT4ge1xyXG4gICAgICBmb3IgKGxldCB0dGxHcmFtbWFyRmlsZW5hbWUgb2YgdHRsR3JhbW1hckZpbGVzKSB7XHJcbiAgICAgICAgbGV0IHR0bEdyYW1tYXJGaWxlQWJzb3VsdGUgPSB0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsR3JhbW1hckZpbGVuYW1lKTtcclxuICAgICAgICBmcy51bmxpbmsodHRsR3JhbW1hckZpbGVBYnNvdWx0ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICB9XHJcbn07XHJcbiJdfQ==